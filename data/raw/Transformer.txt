Transformer (deep learning)
In deep learning, the transformer is an artificial neural
network architecture based on the multi-head attention
mechanism, in which text is converted to numerical
representations called tokens, and each token is converted
into a vector via lookup from a word embedding table.[1] At
each layer, each token is then contextualized within the
scope of the context window with other (unmasked) tokens
via a parallel multi-head attention mechanism, allowing
the signal for key tokens to be amplified and less important
tokens to be diminished.
Transformers have the advantage of having no recurrent
units, therefore requiring less training time than earlier
recurrent neural architectures (RNNs) such as long shortterm memory (LSTM).[2] Later variations have been widely
adopted for training large language models (LLMs) on
large (language) datasets.
[3]
The modern version of the transformer was proposed in
the 2017 paper "Attention Is All You Need" by researchers
at Google.
[1] The predecessors of transformers were
developed as an improvement over previous architectures for machine translation,
[4][5] but have
found many applications since. They are used in large-scale natural language processing, computer
vision (vision transformers), reinforcement learning,
[6][7] audio,
[8] multimodal learning,
robotics,
[9] and even playing chess.
[10]
It has also led to the development of pre-trained systems,
such as generative pre-trained transformers (GPTs)[11] and BERT[12]
(bidirectional encoder
representations from transformers).
For many years, sequence modelling and generation was done by using plain recurrent neural
networks (RNNs). A well-cited early example was the Elman network (1990). In theory, the
information from one token can propagate arbitrarily far down the sequence, but in practice the
vanishing-gradient problem leaves the model's state at the end of a long sentence without precise,
extractable information about preceding tokens.
A key breakthrough was LSTM (1995),[note 1] an RNN which used various innovations to overcome
the vanishing gradient problem, allowing efficient learning of long-sequence modelling. One key
innovation was the use of an attention mechanism which used neurons that multiply the outputs of
other neurons, so-called multiplicative units.
[13] Neural networks using multiplicative units were
later called sigma-pi networks[14] or higher-order networks.
[15] LSTM became the standard
History
Predecessors
28/12/2025 22:52 Transformer (deep learning) - Wikipedia
https://en.wikipedia.org/wiki/Transformer_(deep_learning) 1/30
architecture for long sequence modelling until the 2017 publication of transformers. However,
LSTM still used sequential processing, like most other RNNs.[note 2] Specifically, RNNs operate one
token at a time from first to last; they cannot operate in parallel over all tokens in a sequence.
Modern transformers overcome this problem, but unlike RNNs, they require computation time
that is quadratic in the size of the context window. The linearly scaling fast weight controller (1992)
learns to compute a weight matrix for further processing depending on the input.[16] One of its two
networks has "fast weights" or "dynamic links" (1981).[17][18][19] A slow neural network learns by
gradient descent to generate keys and values for computing the weight changes of the fast neural
network which computes answers to queries.[16] This was later shown to be equivalent to the
unnormalized linear transformer.[20][21]
The idea of encoder–decoder sequence transduction had been developed in the early 2010s;
commonly cited as the originators that produced seq2seq are two concurrently published papers
from 2014.[22][23]
A 380M-parameter model for machine translation uses two long short-term memories (LSTM).[23]
Its architecture consists of two parts. The encoder is an LSTM that takes in a sequence of tokens
and turns it into a vector. The decoder is another LSTM that converts the vector into a sequence of
tokens. Similarly, another 130M-parameter model used gated recurrent units (GRU) instead of
LSTM.[22] Later research showed that GRUs are neither better nor worse than LSTMs for
seq2seq.[24][25]
These early seq2seq models had no attention mechanism, and the state vector is accessible only
after the last word of the source text was processed. Although in theory such a vector retains the
information about the whole original sentence, in practice the information is poorly preserved.
This is because the input is processed sequentially by one recurrent network into a fixed-size
output vector, which is then processed by another recurrent network into an output. If the input is
long, then the output vector would not be able to contain all relevant information, degrading the
output. As evidence, reversing the input sentence improved seq2seq translation.[26]
The RNN search model introduced an attention mechanism to seq2seq for machine translation to
solve the bottleneck problem (of the fixed-size output vector), allowing the model to process longdistance dependencies more easily. The name is because it "emulates searching through a source
sentence during decoding a translation".[4]
The relative performances were compared between global (that of RNN search) and local (sliding
window) attention model architectures for machine translation, finding that mixed attention had
higher quality than global attention, while local attention reduced translation time.[27]
In 2016, Google Translate was revamped to Google Neural Machine Translation, which replaced
the previous model based on statistical machine translation. The new model was a seq2seq model
where the encoder and the decoder were both 8 layers of bidirectional LSTM.[28]
It took nine
months to develop, and it outperformed the statistical approach, which took ten years to
develop.[29]
Attention with seq2seq
28/12/2025 22:52 Transformer (deep learning) - Wikipedia
https://en.wikipedia.org/wiki/Transformer_(deep_learning) 2/30
Seq2seq models with attention (including self-attention) still suffered from the same issue with
recurrent networks, which is that they are hard to parallelize, which prevented them from being
accelerated on GPUs. In 2016, decomposable attention applied a self-attention mechanism to
feedforward networks, which are easy to parallelize, and achieved SOTA result in textual
entailment with an order of magnitude fewer parameters than LSTMs.[30] One of its authors,
Jakob Uszkoreit, suspected that attention without recurrence would be sufficient for language
translation, thus the title "attention is all you need".[31] That hypothesis was against conventional
wisdom at the time, and even his father Hans Uszkoreit, a well-known computational linguist, was
skeptical.[31]
In the same year, self-attention (called intra-attention or intra-sentence attention)
was proposed for LSTMs.[32]
In 2017, the original (100M-sized) encoder–decoder transformer model was proposed in the
"Attention is all you need" paper. At the time, the focus of the research was on improving seq2seq
for machine translation, by removing its recurrence to process all tokens in parallel, but preserving
its dot-product attention mechanism to keep its text processing performance.[1] This led to the
introduction of a multi-head attention model that was easier to parallelize due to the use of
independent heads and the lack of recurrence. Its parallelizability was an important factor to its
widespread use in large neural networks.[33]
As early as spring 2017, even before the "Attention is all you need" preprint was published, one of
the co-authors applied the "decoder-only" variation of the architecture to generate fictitious
Wikipedia articles.[34] Transformer architecture is now used alongside many generative models
that contribute to the ongoing AI boom.
In language modelling, ELMo (2018) was a bi-directional LSTM that produces contextualized word
embeddings, improving upon the line of research from bag of words and word2vec. It was followed
by BERT (2018), an encoder-only transformer model.[35]
In 2019 October, Google started using
BERT to process search queries.[36]
In 2020, Google Translate replaced the previous RNNencoder–RNN-decoder model by a transformer-encoder–RNN-decoder model.[37]
Starting in 2018, the OpenAI GPT series of decoder-only transformers became state of the art in
natural language generation. In 2022, a chatbot based on GPT-3, ChatGPT, became
unexpectedly[38]
 popular, triggering a boom around large language models.
[39][40]
Since 2020, transformers have been applied in modalities beyond text, including the vision
transformer,
[41] speech recognition,[42] robotics,[6] and multimodal.
[43] The vision transformer, in
turn, stimulated new developments in convolutional neural networks.
[44]
Image and video
generators like DALL-E (2021), Stable Diffusion 3 (2024),[45] and Sora (2024), use transformers to
analyse input data (like text prompts) by breaking it down into "tokens" and then calculating the
relevance between each token using self-attention, which helps the model understand the context
and relationships within the data.
Parallelizing attention
AI boom era
28/12/2025 22:52 Transformer (deep learning) - Wikipedia
https://en.wikipedia.org/wiki/Transformer_(deep_learning) 3/30
The plain transformer architecture had difficulty in converging. In the original paper,[1]
the
authors recommended using learning rate warmup. That is, the learning rate should linearly scale
up from 0 to maximal value for the first part of the training (usually recommended to be 2% of the
total number of training steps), before decaying again.
A 2020 paper found that using layer normalization before (instead of after) multihead attention
and feedforward layers stabilizes training, not requiring learning rate warmup.[46]
Transformers typically are first pretrained by self-supervised learning on a large generic dataset,
followed by supervised fine-tuning on a small task-specific dataset. The pretrain dataset is typically
an unlabeled large corpus, such as The Pile. Tasks for pretraining and fine-tuning commonly
include:
language modeling[12]
next-sentence prediction[12]
question answering[3]
reading comprehension
sentiment analysis[1]
paraphrasing[1]
The T5 transformer report[47] documents a large number of natural language pretraining tasks.
Some examples are:
restoring or repairing incomplete or corrupted text. For example, the input, "Thank you ~~ me to
your party ~~ week", might generate the output, "Thank you for inviting me to your party last
week".
translation between natural languages (machine translation)
judging the pragmatic acceptability of natural language. For example, the following sentence
might be judged "not acceptable",[48]
 because even though it is syntactically well-formed, it is
improbable in ordinary human usage: The course is jumping well.
Note that while each of these tasks is trivial or obvious for human native speakers of the language
(or languages), they have typically proved challenging for previous generations of machine learning
architecture.
In general, there are 3 classes of language modelling tasks: "masked",[49] "autoregressive",[50] and
"prefixLM".[51] These classes are independent of a specific modeling architecture such as
transformer, but they are often discussed in the context of transformer.
Training
Methods for stabilizing training
Pretrain-finetune
Tasks
28/12/2025 22:52 Transformer (deep learning) - Wikipedia
https://en.wikipedia.org/wiki/Transformer_(deep_learning) 4/30
In a masked task,[49] one or more of the tokens is masked out, and the model would produce a
probability distribution predicting what the masked-out tokens are based on the context. The loss
function for the task is typically sum of log-perplexities for the masked-out tokens:
and the model is trained to minimize this loss function. The BERT series of models are trained for
masked token prediction and another task.
In an autoregressive task,[50]
the entire sequence is masked at first, and the model produces a
probability distribution for the first token. Then the first token is revealed and the model predicts
the second token, and so on. The loss function for the task is still typically the same. The GPT
series of models are trained by autoregressive tasks.
In a prefixLM task,[51]
the sequence is divided into two parts. The first part is presented as context,
and the model predicts the first token of the second part. Then that would be revealed, and the
model predicts the second token, and so on. The loss function for the task is still typically the same.
The T5 series of models are trained by prefixLM tasks.
Note that "masked" as in "masked language modelling" is not "masked" as in "masked attention",
and "prefixLM" as in "prefix language modeling" is not "prefixLM" as in " prefix language model".
All transformers have the same primary components:
Tokenizers, which convert text into tokens.
Embedding layer, which converts tokens and positions of the tokens into vector
representations.
Transformer layers, which carry out repeated transformations on the vector representations,
extracting more and more linguistic information. These consist of alternating attention and
feedforward layers. There are two major types of transformer layers: encoder layers and
decoder layers, with further variants.
Un-embedding layer, which converts the final vector representations back to a probability
distribution over the tokens.
The following description follows exactly the transformer as described in the original paper. There
are variants, described in the following section.
By convention, we write all vectors as row vectors. For example, pushing a vector through a linear
layer means multiplying it by a weight matrix on the right, as .
As the transformer architecture natively consists of operations over numbers (matrix
multiplications, dot products, activation functions) rather than over text, there must first be a
mapping from any input text to some numerical representation. This happens in three steps.
First, the input text is treated by a preprocessor, which performs both textual transformations and
splits the text into coarse-grained segments called pretokens. The latter is referred to as
pretokenization. Second, each pretoken is segmented further into tokens by a tokenizer that
Architecture
Tokenization
28/12/2025 22:52 Transformer (deep learning) - Wikipedia
https://en.wikipedia.org/wiki/Transformer_(deep_learning) 5/30
expects to only see pretokens output by its preprocessor. Each token it produces is a string of one
or more characters belonging to a finite set of strings called the vocabulary . Third, because the
vocabulary is finite and known beforehand, each token can be assigned an integer identifier, and
this mapping is applied to the sequence of tokens to represent any input text as a numerical
sequence. Since this mapping is bijective, the output side can produce a sequence of integer
identifiers which can then be turned back into tokens. After undoing some of the preprocessing,
the result is again legible text.
Training a tokenizer (sometimes referred to as vocabularization) means finding a suitable
vocabulary , but also learning how to use it, since any given string of length has
hypothetical segmentations, some of which containing segments that are not in the vocabulary.
The most important hyperparameter during vocabularization is the vocabulary size : when it is
small, the learned vocabulary generally consists of characters and smaller strings, and words will
be segmented into many tokens. At larger sizes, it becomes affordable to dedicate tokens to full
words, although depending on the preprocessor and tokenizer, it is not necessarily the case that
large vocabularies will always use the largest token(s) available to segment a word.
Because tokens are not always full words, they may also be referred to as subwords and
tokenization algorithms may be referred to as subword tokenizers. This is also to differentiate
these systems from traditional terminology used in older information retrieval and natural
language processing systems, where "tokenization" was used to denote what is today called
"pretokenization" (very crudely: splitting into words). In tokenizers that produce tokens that are
not part of the vocabulary, a special token that does belong to the vocabulary is used as a generic
stand-in, written as "[UNK]" for "unknown". In principle, any string could be hidden by such an
[UNK]. Indeed, in information retrieval, pretokenizers were themselves used as tokenizers (and
also called "tokenizers") with a word-level vocabulary that contained an [UNK].
Commonly used subword tokenization algorithms are byte pair encoding (BPE) and the unigram
language model (ULM), which each include a vocabularization algorithm and a dedicated
segmentation algorithm. There also exist several segmentation algorithms that require no learning
and can be applied given a vocabulary (produced by BPE or ULM, for example), like greedily
recognising tokens in a pretoken by moving through it left-to-right. Well-known software
implementations of subword tokenizers are Hugging Face's tokenizers Python package
implemented in Rust, and the sentencepiece Python package implemented in C++. The latter
package is named as such because one of its configuration options allows disabling the built-in
pretokenizer, hence effectively making entire sentences a pretoken and thus having the tokenizer
see entire sentences, rather than individual words.
Each integer token identifier is converted into an embedding vector via a lookup table.
Equivalently stated, it multiplies a one-hot representation of the token identifier by an embedding
matrix . For example, if the input token's identifier is , then the one-hot representation is
, and its embedding vector is
The token embedding vectors are added to their respective positional encoding vectors (see below),
producing the sequence of input vectors.
Embedding
28/12/2025 22:52 Transformer (deep learning) - Wikipedia
https://en.wikipedia.org/wiki/Transformer_(deep_learning) 6/30
Illustration of (absolute) positional
encoding with parameters
The dimension of an embedding vector is called hidden size or embedding size and written as
.
[35]
 This size is written as in the original transformer paper.[1]
An un-embedding layer is almost the reverse of an embedding layer. Whereas an embedding layer
converts a token identifier into a vector, an un-embedding layer converts a vector into a probability
distribution over tokens.
The un-embedding layer is a linear-softmax layer:
The matrix has shape . Some architectures use the transpose of the embedding matrix
as the un-embedding matrix in order to avoid needing double the amount of embeddingrelated parameters and to avoid divergence during training. This practice is called weight tying.
[52]
A positional encoding is a fixed-size vector representation
of the relative positions of tokens within a sequence: it
provides the transformer model with information about
where the words are in the input sequence. This induces a
bias towards the order of the input sequence, so that, for
example, the input sequence "man bites dog" is processed
differently from "dog bites man".
The positional encoding is defined as a function of type
, where is a positive even integer. The full
positional encoding defined in the original paper[1]
 is:
where .
Here, is a free parameter that should be significantly larger than the biggest that would be
input into the positional encoding function. The original paper uses .
The function is in a simpler form when written as a complex function of type
where .
The main reason for using this positional encoding function is that using it, shifts are linear
transformations:
where is the distance one wishes to shift. This allows the transformer to take any encoded
position, and find the encoding of the position n-steps-ahead or n-steps-behind, by a matrix
multiplication.
Un-embedding
Positional encoding
28/12/2025 22:52 Transformer (deep learning) - Wikipedia
https://en.wikipedia.org/wiki/Transformer_(deep_learning) 7/30
One encoder–decoder block
A transformer is composed of stacked
encoder layers and decoder layers.
By taking a linear sum, any convolution can also be implemented as linear transformations:
for any constants . This allows the transformer to take any encoded position and find a linear
sum of the encoded locations of its neighbors. This sum of encoded positions, when fed into the
attention mechanism, would create attention weights on its neighbors, much like what happens in
a convolutional neural network language model. In the author's words, "we hypothesized it would
allow the model to easily learn to attend by relative position."
In typical implementations, all operations are done over the real numbers, not the complex
numbers, but since complex multiplication can be implemented as real 2-by-2 matrix
multiplication, this is a mere notational difference.
Like earlier seq2seq models, the original transformer model
used an encoder–decoder architecture. The encoder consists
of encoding layers that process all the input tokens together
one layer after another, while the decoder consists of decoding
layers that iteratively process the encoder's output and the
decoder's output tokens so far.
The purpose of each encoder layer is to create contextualized
representations of the tokens, where each representation
corresponds to a token that "mixes" information from
other input tokens via self-attention mechanism. Each
decoder layer contains two attention sublayers: (1) crossattention for incorporating the output of encoder
(contextualized input token representations), and (2) selfattention for "mixing" information among the input tokens
to the decoder (i.e. the tokens generated so far during
inference time).[53][54]
Both the encoder and decoder layers have a feed-forward
neural network for additional processing of their outputs and contain residual connections and
layer normalization steps.[54] These feed-forward layers contain most of the parameters in a
transformer model.
The feedforward network (FFN) modules in a transformer are 2-layered multilayer perceptrons:
where and are weight matrices and and are bias vectors, and is its activation
function. The original transformer used ReLU activation.
Encoder–decoder (overview)
Feedforward network
28/12/2025 22:52 Transformer (deep learning) - Wikipedia
https://en.wikipedia.org/wiki/Transformer_(deep_learning) 8/30
The feedforward network module. It is a
two-layered network that maps -
dimensional vectors into -
dimensional vectors.
The number of neurons in the middle layer is called
intermediate size (GPT),[55]
filter size (BERT),[35] or
feedforward size (BERT).[35]
It is typically larger than the
embedding size. For example, in both GPT-2 series and
BERT series, the intermediate size of a model is 4 times its
embedding size: .
The attention mechanism used in the transformer
architecture are scaled dot-product attention units. For
each unit, the transformer model learns three weight
matrices: the query weights , the key weights , and the value weights .
The module takes three sequences, a query sequence, a key sequence, and a value sequence. The
query sequence is a sequence of length , and each entry is a vector of dimension
. Similarly for the key and value sequences.
For each vector in the query sequence, it is multiplied by a matrix to produce a query
vector . The matrix of all query vectors is the query matrix:
Similarly, we construct the key matrix and the value matrix .
It is usually the case that all are square matrices, meaning , etc.
Attention weights are calculated using the query and key vectors: the attention weight from
token to token is the dot product between and . The attention weights are divided by the
square root of the dimension of the key vectors, , which stabilizes gradients during training,
and passed through a softmax which normalizes the weights. The fact that and are
different matrices allows attention to be non-symmetric: if token attends to token (i.e. is
large), this does not necessarily mean that token will attend to token (i.e. could be small).
The output of the attention unit for token is the weighted sum of the value vectors of all tokens,
weighted by , the attention from token to each token.
The attention calculation for all tokens can be expressed as one large matrix calculation using the
softmax function, which is useful for training due to computational matrix operation optimizations
that quickly compute matrix operations. The matrices , and are defined as the matrices
where the th rows are vectors , , and respectively. Then we can represent the attention as
where the softmax is applied over each of the rows of the matrix.
Scaled dot-product attention
Attention head
28/12/2025 22:52 Transformer (deep learning) - Wikipedia
https://en.wikipedia.org/wiki/Transformer_(deep_learning) 9/30
Scaled dot-product attention, block
diagram
Exact dimension counts within an
attention head module
The number of dimensions in a query vector is query size
and similarly for the key size and value size
. The output dimension of an attention head is its
head dimension . The attention mechanism requires
the following three equalities to hold:
but is otherwise unconstrained.
If the attention head is used in a self-attention fashion,
then . If the attention head is used
in a cross-attention fashion, then usually
. It is theoretically possible for all
three to be different, but that is rarely the case in practice.
One set of matrices is called an attention
head, and each layer in a transformer model has multiple
attention heads. While each attention head attends to the
tokens that are relevant to each token, multiple attention
heads allow the model to do this for different definitions of
"relevance". Specifically, the query and key projection
matrices, and , which are involved in the
attention score computation, defines the "relevance".
Meanwhile, the value projection matrix , in
combination with the part of the output projection matrix
, determines how the attended tokens influence what
information is passed to subsequent layers and ultimately
the output logits. In addition, the scope of attention, or the
range of token relationships captured by each attention
head, can expand as tokens pass through successive layers.
This allows the model to capture more complex and longrange dependencies in deeper layers. Many transformer
attention heads encode relevance relations that are
meaningful to humans. For example, some attention heads
can attend mostly to the next word, while others mainly
attend from verbs to their direct objects.[56] The
computations for each attention head can be performed in
parallel, which allows for fast processing. The outputs for
the attention layer are concatenated to pass into the
feedforward neural network layers.
Concretely, let the multiple attention heads be indexed by
, then we have
Multihead attention
28/12/2025 22:52 Transformer (deep learning) - Wikipedia
https://en.wikipedia.org/wiki/Transformer_(deep_learning) 10/30
Multihead attention, block diagram
Exact dimension counts within a
multihead attention module
where the matrix is the concatenation of word
embeddings, and the matrices are
"projection matrices" owned by individual attention head ,
and is a final projection matrix owned by the whole
multihead attention head.
It is theoretically possible for each attention head to have a
different head dimension , but that is rarely the case
in practice.
As an example, in the smallest GPT-2 model, there are only
self-attention mechanisms. It has the following
dimensions:
Since , its output projection matrix
 is a square matrix.
The transformer architecture is constructed to calculate
output tokens iteratively. Assuming refers to the
calculation of the first output token , for step ,
the output token shall remain constant. This ensures
properties of the model similar to autoregressive models.
[1]
Therefore, at every time step , the calculation for all outputs should not have access to tokens at
position for (as it naturally is the case for time step , when tokens are not yet
calculated). This behavior may be accomplished before the softmax stage by adding a mask matrix
 that is at entries where the attention link must be cut, and at other places:
The following matrix is commonly used in decoder self-attention modules, called "causal masking":
In words, it means that each token can pay attention to itself, and every token before it, but not any
after it. A non-masked attention module can be thought of as a masked attention module where the
mask has all entries zero. As an example of an uncommon use of mask matrix, the XLNet considers
all masks of the form , where is a random permutation matrix.
[57]
An encoder consists of an embedding layer, followed by multiple encoder layers.
Masked attention
Encoder
28/12/2025 22:52 Transformer (deep learning) - Wikipedia
https://en.wikipedia.org/wiki/Transformer_(deep_learning) 11/30
One encoder layer
One decoder layer
Each encoder layer consists of two major components: a
self-attention mechanism and a feed-forward layer. It takes
an input as a sequence of input vectors, applies the selfattention mechanism, to produce an intermediate
sequence of vectors, then applies the feed-forward layer for
each vector individually. Schematically, we have:
where stands for "feed-forward network". We can more succinctly write it as
with the implicit convention that the is applied to each row of the matrix individually.
The encoder layers are stacked. The first encoder layer takes the sequence of input vectors from the
embedding layer, producing a sequence of vectors. This sequence of vectors is processed by the
second encoder, and so on. The output from the final encoder layer is then used by the decoder.
As the encoder processes the entire input all at once, every token can attend to every other token
(all-to-all attention), so there is no need for causal masking.
A decoder consists of an embedding layer, followed by
multiple decoder layers, followed by an un-embedding
layer.
Each decoder consists of three major components: a
causally masked self-attention mechanism, a crossattention mechanism, and a feed-forward neural network.
The decoder functions in a similar fashion to the encoder,
but an additional attention mechanism is inserted which
instead draws relevant information from the encodings
generated by the encoders. This mechanism can also be called the encoder–decoder
attention.
[1][54]
Like the first encoder, the first decoder takes positional information and embeddings of the output
sequence as its input, rather than encodings. The transformer must not use the current or future
output to predict an output, so the output sequence must be partially masked to prevent this
reverse information flow.[1] This allows for autoregressive text generation. For decoding, all-to-all
attention is inappropriate, because a token cannot attend to tokens not yet generated. Thus, the
self-attention module in the decoder is causally masked.
Decoder
28/12/2025 22:52 Transformer (deep learning) - Wikipedia
https://en.wikipedia.org/wiki/Transformer_(deep_learning) 12/30
(a) One encoder layer and one decoder
layer. (b) Two encoder layers and two
decoder layers. The sublayers are
labelled as well.
In contrast, the cross-attention mechanism attends to the output vectors of the encoder, which is
computed before the decoder starts decoding. Consequently, there is no need for masking in the
cross-attention mechanism.
Schematically, we have:
where is the matrix with rows being the output vectors from the encoder.
The last decoder is followed by a final un-embedding layer to produce the output probabilities over
the vocabulary. Then, one of the tokens is sampled according to the probability, and the decoder
can be run again to produce the next token, etc., autoregressively generating output text.
Each encoder layer contains 2 sublayers: the self-attention
and the feedforward network. Each decoder layer contains
3 sublayers: the causally masked self-attention, the crossattention, and the feedforward network.
The final points of detail are the residual connections and
layer normalization, (denoted as "LayerNorm", or "LN" in
the following), which while conceptually unnecessary, are
necessary for numerical stability and convergence.
The residual connection, which is introduced to avoid
vanishing gradient issues and stabilize the training
process, can be expressed as follows: y = F(x) + x. The
expression indicates that an output y is the sum of the
transformation of input x (F(x)) and the input itself (x).
Adding the input x can preserve the input information and
avoid issues when the gradient of F(x) is close to zero.
Similarly to how the feedforward network modules are applied individually to each vector, the
LayerNorm is also applied individually to each vector.
There are two common conventions in use: the post-LN and the pre-LN convention. In the postLN convention, the output of each sublayer is
where is the function implemented by the sublayer itself.
In the pre-LN convention, the output of each sublayer is
The original 2017 transformer used the post-LN convention. It was difficult to train and required
Full transformer architecture
Sublayers
28/12/2025 22:52 Transformer (deep learning) - Wikipedia
https://en.wikipedia.org/wiki/Transformer_(deep_learning) 13/30
Transformer encoder with norm-first and
norm-last
Transformer decoder with norm-first and
norm-last
Block diagram for the full transformer
architecture
careful hyperparameter tuning and a "warm-up" in
learning rate, where it starts small and gradually increases.
The pre-LN convention, proposed several times in
2018,[58] was found to be easier to train, requiring no
warm-up, leading to faster convergence.[46]
The following is the pseudocode for a standard pre-LN
encoder–decoder transformer, adapted from Formal
Algorithms for Transformers[59]
input: Encoder input t_e
Decoder input t_d
output: Array of probability distributions, with shape (decoder
vocabulary size x length(decoder output sequence))
/* encoder */
z_e ← encoder.tokenizer(t_e)
for each t in 1:length(z_e) do
z_e[t] ← encoder.embedding(z_e[t]) +
encoder.positional_embedding(t)
for each l in 1:length(encoder.layers) do
layer ← encoder.layers[l]
/* first sublayer */
z_e_copy ← copy(z_e)
for each t in 1:length(z_e) do
z_e[t] ← layer.layer_norm(z_e[t])
z_e ← layer.multihead_attention(z_e, z_e, z_e)
for each t in 1:length(z_e) do
z_e[t] ← z_e[t] + z_e_copy[t]
/* second sublayer */
z_e_copy ← copy(z_e)
for each t in 1:length(z_e) do
z_e[t] ← layer.layer_norm(z_e[t])
z_e ← layer.feedforward(z_e)
for each t in 1:length(z_e) do
z_e[t] ← z_e[t] + z_e_copy[t]
for each t in 1:length(z_e) do
z_e[t] ← encoder.final_layer_norm(z_e[t])
/* decoder */
z_d ← decoder.tokenizer(t_d)
for each t in 1:length(z_d) do
z_d[t] ← decoder.embedding(z_d[t]) +
decoder.positional_embedding(t)
for each l in 1:length(decoder.layers) do
layer ← decoder.layers[l]
/* first sublayer */
z_d_copy ← copy(z_d)
for each t in 1:length(z_d) do
z_d[t] ← layer.layer_norm(z_d[t])
z_d ← layer.masked_multihead_attention(z_d, z_d, z_d)
for each t in 1:length(z_d) do
z_d[t] ← z_d[t] + z_d_copy[t]
/* second sublayer */
z_d_copy ← copy(z_d)
for each t in 1:length(z_d) do
z_d[t] ← layer.layer_norm(z_d[t])
z_d ← layer.multihead_attention(z_d, z_e, z_e)
for each i in 1:length(z_d) do
z_d[t] ← z_d[t] + z_d_copy[t]
Pseudocode
28/12/2025 22:52 Transformer (deep learning) - Wikipedia
https://en.wikipedia.org/wiki/Transformer_(deep_learning) 14/30
Schematic object hierarchy for the full
transformer architecture, in objectoriented programming style
/* third sublayer */
z_d_copy ← copy(z_d)
for each t in 1:length(z_d) do
z_d[t] ← layer.layer_norm(z_d[t])
z_d ← layer.feedforward(z_d)
for each t in 1:length(z_d) do
z_d[t] ← z_d[t] + z_d_copy[t]
z_d ← decoder.final_layer_norm(z_d)
output_distributions ← []
for each t in 1:length(z_d) do
output_distributions.append(decoder.unembed(z_d[t]))
return output_distributions
The transformer architecture, being modular, allows variations. Several common variations are
described here.[60]
An "encoder-only" transformer applies the encoder to map an input text into a sequence of vectors
that represent the input text. This is usually used for text embedding and representation learning
for downstream applications. BERT is encoder-only. They are less often used currently, as they
were found to be not significantly better than training an encoder–decoder transformer, then
taking just the encoder.[51]
 They are also referred to as "all-to-all" or "BERT-like".
A "decoder-only" transformer is not literally decoder-only, since without an encoder, the crossattention mechanism has nothing to attend to. Thus, the decoder layers in a decoder-only
transformer is composed of just two sublayers: the causally masked self-attention, and the
feedforward network. This is usually used for text generation and instruction following. The
models in the GPT series and Chinchilla series are decoder-only. They are also referred to as
"autoregressive" or "causal".
An "encoder–decoder" transformer is generally the same as the original transformer, with 2
sublayers per encoder layer and 3 sublayers per decoder layer, etc. They might have minor
architectural improvements, such as alternative activation functions, changing the location of
normalization, etc. This is also usually used for text generation and instruction following. The
models in the T5 series are encoder–decoder.[60]
A "prefixLM" (prefix language model) is a decoder-only architecture, but with prefix masking,
which is different from causal masking. Specifically, it has mask of the form[60]:Figure 3
where the first columns correspond to the "prefix", and the subsequent columns correspond to the
autoregressively generated text based on the prefix. They resemble encoder–decoder models, but
has less "sparsity". Such models are rarely used, though they are cited as theoretical possibilities
and benchmarked comparisons.[51]
There are also mixed seq2seq models. For example, in 2020, Google Translate replaced the
previous RNN-encoder–RNN-decoder model with a transformer-encoder–RNN-decoder model, as
transformer-based decoders did not appear to significantly increase quality unlike the encoder,
while the RNN decoder was much faster.[37]
Terminology
28/12/2025 22:52 Transformer (deep learning) - Wikipedia
https://en.wikipedia.org/wiki/Transformer_(deep_learning) 15/30
The original transformer uses ReLU activation function. Other activation functions were
developed. The Llama series and PaLM used SwiGLU;[61] both GPT-1 and BERT[35] used
GELU.[62]
Alternative activation functions are often used in combination with Gated Linear Units in the
feedforward module.[61]
The normalization used in the transformer can be different from LayerNorm. One example is
RMSNorm[63] which is used in the Llama series. Other examples include CapsuleNorm[64]
ScaleNorm,[65]
 or FixNorm.[65]
Transformers may use other positional encoding methods than sinusoidal.[66]
The original transformer paper reported using a learned positional encoding,[67] but finding it not
superior to the sinusoidal one.[1] Later,[68]
found that causal masking itself provides enough signal
to a transformer decoder that it can learn to implicitly perform absolute positional encoding
without the positional encoding module.
RoPE (rotary positional embedding),[69]
is best explained by considering a list of 2-dimensional
vectors . Now pick some angle . Then RoPE encoding is
Equivalently, if we write the 2-dimensional vectors as complex numbers , then
RoPE encoding is just multiplication by an angle:
For a list of -dimensional vectors, a RoPE encoder is defined by a sequence of angles
. Then the RoPE encoding is applied to each pair of coordinates.
The benefit of RoPE is that the dot-product between two vectors depends on their relative location
only:
for any integer .
Subsequent work
Alternative activation functions
Alternative normalizations
Alternative positional encodings
RoPE
28/12/2025 22:52 Transformer (deep learning) - Wikipedia
https://en.wikipedia.org/wiki/Transformer_(deep_learning) 16/30
ALiBi (Attention with Linear Biases)[70]
is not a replacement for the positional encoder on the
original transformer. Instead, it is an additional positional encoder that is directly plugged into the
attention mechanism. Specifically, the ALiBi attention mechanism is
Here, is a real number ("scalar"), and is the linear bias matrix defined by
in other words, . The idea being that the linear bias matrix is a softened mask. Just as
represent full attention paid, and represents no attention paid, the linear bias matrix
increases attention paid in one direction and decreases attention paid in the other direction.
ALiBi allows pretraining on short context windows, then fine-tuning on longer context windows.
Since it is directly plugged into the attention mechanism, it can be combined with any positional
encoder that is plugged into the "bottom" of the entire network (which is where the sinusoidal
encoder on the original transformer, as well as RoPE and many others, are located).
Relative Position Encodings[71]
 is similar to ALiBi, but more generic:
where is a Toeplitz matrix, that is, whenever . This is contrasted with
the original sinusoidal positional encoding, which is an "absolute positional encoding".[72]
The transformer model has been implemented in standard deep learning frameworks such as
TensorFlow and PyTorch. Transformers is a library produced by Hugging Face that supplies
transformer-based architectures and pretrained models.[11]
When an autoregressive transformer is used for inference, such as generating text, the query vector
is different at each step, but the already-computed key and value vectors are always the same. The
KV caching method saves the computed key and value vectors at each attention block, so that
they are not recomputed at each new token. PagedAttention applies memory paging to KV
caching.[73][74][75]
ALiBi
Relative Position Encodings
Efficient implementation
KV caching
28/12/2025 22:52 Transformer (deep learning) - Wikipedia
https://en.wikipedia.org/wiki/Transformer_(deep_learning) 17/30
Comparison between several different
forms of attention mechanism and the
amount of KV caching necessary for
each
If a transformer is used with a baked-in prompt, such as ["You are a customer support agent..."],
then the key and value vectors can be computed for the prompt, and saved on disk. The saving in
compute is significant when the model is used for many short real-time interactions, such as in
online chatbots.
FlashAttention[76]
is an algorithm that implements the transformer attention mechanism
efficiently on a GPU. It is a communication-avoiding algorithm that performs matrix
multiplications in blocks, such that each block fits within the cache of a GPU, and by careful
management of the blocks it minimizes data copying between GPU caches (as data movement is
slow). See the page on softmax for details.
An improved version, FlashAttention-2,[77][78][79] was developed to cater to the rising demand for
language models capable of handling longer context lengths. It offers enhancements in work
partitioning and parallelism, enabling it to achieve up to 230 TFLOPs/s on A100 GPUs
(FP16/BF16), a 2x speed increase over the original FlashAttention.
Key advancements in FlashAttention-2 include the reduction of non-matmul FLOPs, improved
parallelism over the sequence length dimension, better work partitioning between GPU warps, and
added support for head dimensions up to 256 and multi-query attention (MQA) and groupedquery attention (GQA).[80]
Benchmarks revealed FlashAttention-2 to be up to 2x faster than FlashAttention and up to 9x
faster than a standard attention implementation in PyTorch. Future developments include
optimization for new hardware like H100 GPUs and new data types like FP8.
FlashAttention-4 focuses on pipelining to increase instruction throughput, and was developed to
perform particularly well on Blackwell GPUs.
[81]
Multi-Query Attention changes the Multihead Attention
mechanism.[82]
 Whereas normally,
with Multi-Query Attention, there is just one , thus:
This has a neutral effect on model quality and training speed, but increases inference speed.
FlashAttention
Multi-Query Attention
28/12/2025 22:52 Transformer (deep learning) - Wikipedia
https://en.wikipedia.org/wiki/Transformer_(deep_learning) 18/30
The architecture of V2, showing both
MLA and a variant of mixture of
experts
[84]:Figure 2
Multi-token prediction
More generally, grouped-query attention (GQA) partitions attention heads into groups, each of
which shares the key-value pair. MQA is GQA with one group, while standard Multihead Attention
is GQA with the maximal number of groups.[83]
Multihead Latent Attention (MLA) is a low-rank
approximation to standard MHA. Specifically, each hidden
vector, before entering the attention mechanism, is first
projected to two low-dimensional spaces ("latent space"),
one for query and one for key-value (KV vector). This
design minimizes the KV cache, as only the lowdimensional KV vector needs to be cached.[84]
Speculative decoding[85][86]
is a method to accelerate
token decoding. Similarly to speculative execution in CPUs,
future tokens are computed quickly, then verified. If the
quickly computed tokens are incorrect, they are discarded
and computed slowly.
The key factor in speculative decoding is that a transformer decoder can verify faster than it can
decode, in the following sense.
Suppose we have two transformer models like GPT-3 and GPT-3-small, both with a context
window size of 512. To generate an entire context window autoregressively with greedy decoding
with GPT-3, it must be run for 512 times, each time generating a token , taking
time . However, if we had some educated guess for the values of these tokens, we could
verify all of them in parallel, in one run of the model, by checking that each is indeed the token
with the largest log-likelihood in the -th output.
In speculative decoding, a smaller model or some other simple heuristic is used to generate a few
speculative tokens that are subsequently verified by the larger model. For example, suppose we use
GPT-3-small to generate four speculative tokens: . This only takes .
These tokens are then run through the larger GPT-3 in one go. Suppose that and are verified
by GPT-3 as what it would have picked, then those are kept, but is not, so are discarded,
and GPT-3 is run on those. This would take , which might be shorter than
.
For non-greedy decoding, similar ideas apply, except the speculative tokens are accepted or
rejected stochastically, in a way that guarantees the final output distribution is the same as if
speculative decoding was not used.[85][87]
In Multi-Token Prediction, a single forward pass creates a
final embedding vector, which then is un-embedded into a
token probability. However, that vector can then be further
processed by another transformer block to predict the next
token, and so on for arbitrarily many steps into the future.
This trades off accuracy for speed, since each new token
costs just one more transformer block, rather than the
entire stack.[88][89]
Speculative decoding
28/12/2025 22:52 Transformer (deep learning) - Wikipedia
https://en.wikipedia.org/wiki/Transformer_(deep_learning) 19/30
Training transformer-based architectures can be expensive, especially for long inputs.[90] Many
methods have been developed to attempt to address the issue. In the image domain, Swin
transformer is an efficient architecture that performs attention inside shifting windows.[91]
In the
audio domain, SepTr decouples the attention in time and frequency domains.[92] Long Range
Arena (2020)[93]
is a standard benchmark for comparing the behavior of transformer architectures
over long inputs.
The standard attention graph is either all-to-all or causal, both of which scales as where
is the number of tokens in a sequence.
Reformer (2020)[90][94] reduces the computational load from to by using
locality-sensitive hashing and reversible layers.[95]
Sparse attention[96] uses attention graphs that grows slower than . For example, BigBird
(2020)[97]
 uses random small-world networks which grows as .
Ordinary transformers require a memory size that is quadratic in the size of the context window.
Attention-free transformers[98] reduce this to a linear dependence while still retaining the
advantages of a transformer by linking the key to the value.
Random Feature Attention (2021)[99]
 uses Fourier random features:
where are independent samples from the normal distribution . This choice
of parameters satisfy , or
Consequently, the one-headed attention, with one query, can be written as
where . Similarly for multiple queries, and for multihead attention.
This approximation can be computed in linear time, as we can compute the matrix first,
then multiply it with the query. In essence, we have managed to obtain a more precise version of
Sub-quadratic transformers
Alternative attention graphs
Random Feature Attention
28/12/2025 22:52 Transformer (deep learning) - Wikipedia
https://en.wikipedia.org/wiki/Transformer_(deep_learning) 20/30
Performer (2022)[100] uses the same Random Feature Attention, but are first
independently sampled from the normal distribution , then they are Gram-Schmidt
processed.
Transformers can also be used/adapted for modalities (input or output) beyond just text, usually
by finding a way to "tokenize" the modality.
Multimodal models can either be trained from scratch, or by finetuning. A 2022 study found that
transformers pretrained only on natural language can be finetuned on only 0.03% of parameters
and become competitive with LSTMs on a variety of logical and visual tasks, demonstrating
transfer learning.
[101] The LLaVA was a vision-language model composed of a language model
(Vicuna-13B)[102] and a vision model (ViT-L/14), connected by a linear layer. Only the linear layer
is finetuned.[103]
Vision transformers[41] adapt the transformer to computer vision by breaking down input images
as a series of patches, turning them into vectors, and treating them like embedding vector of tokens
in a standard transformer.
Conformer[42] and later Whisper[104]
follow the same pattern for speech recognition, first turning
the speech signal into a spectrogram, which is then treated like an image, i.e. broken down into a
series of patches, turned into vectors and treated like embedding vector of tokens in a standard
transformer.
Perceivers[105][106]
 are a variant of transformers designed for multimodality.
For image generation, notable architectures are DALL-E 1 (2021), Parti (2022),[107] Phenaki
(2023),[108] and Muse (2023).[109] Unlike later models, DALL-E is not a diffusion model. Instead,
it uses a decoder-only transformer that autoregressively generates a text, followed by the token
representation of an image, which is then converted by a variational autoencoder to an image.[110]
Parti is an encoder–decoder transformer, where the encoder processes a text prompt, and the
decoder generates a token representation of an image.[111] Muse is an encoder-only transformer
that is trained to predict masked image tokens from unmasked image tokens. During generation,
all input tokens are masked, and the highest-confidence predictions are included for the next
iteration, until all tokens are predicted.[109] Phenaki is a text-to-video model. It is a bidirectional
masked transformer conditioned on pre-computed text tokens. The generated tokens are then
decoded to a video.[108]
The transformer has had great success in natural language processing (NLP). Many large language
models such as GPT-2, GPT-3, GPT-4, Gemini, AlbertAGPT, Claude, BERT, Grok, XLNet,
RoBERTa and ChatGPT demonstrate the ability of transformers to perform a wide variety of NLPrelated subtasks and their related real-world applications, including:
machine translation
time series prediction
document summarization
Multimodality
Applications
28/12/2025 22:52 Transformer (deep learning) - Wikipedia
https://en.wikipedia.org/wiki/Transformer_(deep_learning) 21/30
document generation
named entity recognition (NER)[112]
writing computer code based on requirements expressed in natural language.
speech-to-text
Beyond traditional NLP, the transformer architecture has had success in other applications, such
as:
biological sequence analysis
video understanding
protein folding (such as AlphaFold)
evaluating chess board positions. Using static evaluation alone (that is, with no Minimax
search) transformer achieved an Elo of 2895, putting it at grandmaster level.[10]
seq2seq – Family of machine learning approaches
Perceiver – Variant of Transformer designed for multimodal data
Vision transformer – Machine learning model for vision processing
Large language model – Type of machine learning model
BERT (language model) – Series of language models developed by Google AI
Generative pre-trained transformer – Type of large language model
T5 (language model) – Series of large language models developed by Google AI
